# 插件化架构文档

## 1. 概述

### 1.1 设计目标

wl-draw 采用插件化架构设计，旨在实现以下目标：

- **可扩展性**：通过插件系统轻松添加新的绘图工具和功能
- **解耦合**：工具实现与核心系统分离，降低代码耦合度
- **可维护性**：每个工具独立实现，便于维护和测试
- **灵活性**：支持动态注册和切换工具，运行时配置

### 1.2 架构优势

- **统一接口**：所有工具遵循相同的插件接口规范
- **生命周期管理**：提供完整的工具激活/停用生命周期
- **快捷键支持**：内置快捷键解析和冲突检测机制
- **类型安全**：完整的 TypeScript 类型定义
- **UI 集成**：插件可配置 UI 显示（图标、标签、分隔符）

### 1.3 核心概念

- **插件（Plugin）**：实现 `ToolPlugin` 接口的工具定义
- **工具实例（Tool Instance）**：由插件工厂函数创建的工具运行时实例
- **插件注册表（Plugin Registry）**：管理所有已注册插件的中央注册表
- **工具上下文（Tool Context）**：提供给工具实例的运行时上下文信息

## 2. 核心组件

### 2.1 插件注册表 (PluginRegistry)

插件注册表是插件系统的核心，负责管理所有工具的注册、查询和管理。

**文件位置**：`src/plugins/registry.ts`

**主要功能**：

```8:68:src/plugins/registry.ts
class PluginRegistry {
  private plugins = new Map<string, ToolPlugin>()

  register(plugin: ToolPlugin): void {
    if (this.plugins.has(plugin.id)) {
      console.warn(`Plugin with id "${plugin.id}" is already registered. Overwriting.`)
    }

    if (plugin.shortcut) {
      const existingShortcuts = Array.from(this.plugins.values())
        .filter((p) => p.shortcut && p.id !== plugin.id)
        .map((p) => {
          if (!p.shortcut) {
            throw new Error('Unexpected: shortcut is undefined')
          }
          return { pluginId: p.id, shortcut: p.shortcut }
        })

      const conflicts = checkShortcutConflict(plugin.shortcut, existingShortcuts)

      if (conflicts.length > 0) {
        const conflictList = conflicts.map((c) => `"${c.pluginId}" (${c.shortcut})`).join(', ')
        console.warn(
          `Shortcut conflict detected for plugin "${plugin.id}": shortcut "${plugin.shortcut}" conflicts with ${conflictList}`
        )
      }
    }

    this.plugins.set(plugin.id, plugin)
  }

  get(id: string): ToolPlugin | undefined {
    return this.plugins.get(id)
  }

  getByType(type: string): ToolPlugin | undefined {
    return Array.from(this.plugins.values()).find((plugin) => plugin.type === type)
  }

  getAll(): ToolPlugin[] {
    return Array.from(this.plugins.values())
  }

  getByCategory(category: string): ToolPlugin[] {
    return Array.from(this.plugins.values()).filter((plugin) => plugin.category === category)
  }

  has(id: string): boolean {
    return this.plugins.has(id)
  }

  unregister(id: string): boolean {
    return this.plugins.delete(id)
  }

  clear(): void {
    this.plugins.clear()
  }
}

export const pluginRegistry = new PluginRegistry()
```

**API 说明**：

- `register(plugin)`: 注册插件，自动检测快捷键冲突
- `get(id)`: 根据 ID 获取插件
- `getByType(type)`: 根据类型获取插件
- `getAll()`: 获取所有已注册的插件
- `getByCategory(category)`: 根据分类获取插件列表
- `has(id)`: 检查插件是否已注册
- `unregister(id)`: 注销插件
- `clear()`: 清空所有插件

### 2.2 类型系统

**文件位置**：`src/plugins/types.ts`

类型系统定义了插件系统的所有核心接口和类型。

#### ToolPlugin 接口

```37:45:src/plugins/types.ts
export interface ToolPlugin {
  id: string
  name: string
  type: string
  category?: PluginCategory
  ui?: ToolPluginUI
  shortcut?: string
  createTool: (context: ToolContext) => ToolInstance
}
```

#### ToolContext 接口

工具上下文提供了工具实例运行所需的所有信息：

```12:20:src/plugins/types.ts
export interface ToolContext {
  tree: Tree
  store: ReturnType<typeof useCanvasStore>
  isDrawing: Ref<boolean>
  startPoint: Ref<Point | null>
  currentElement: Ref<LeaferElement>
  isShiftPressed: Ref<boolean>
  penPathPoints?: Ref<Array<Point>>
}
```

#### ToolInstance 接口

工具实例定义了工具的生命周期方法：

```22:29:src/plugins/types.ts
export interface ToolInstance {
  handleMouseDown?: () => void
  updateDrawing?: (e: DragEvent) => void
  finishDrawing?: () => void
  handleTap?: (e: PointerEvent) => void
  onActivate?: () => void
  onDeactivate?: () => void
}
```

#### PluginCategory 类型

```10:10:src/plugins/types.ts
export type PluginCategory = 'drawing' | 'selection' | 'utility'
```

### 2.3 快捷键系统

**文件位置**：`src/plugins/shortcut.ts`

快捷键系统提供了快捷键解析、标准化和冲突检测功能。

**核心功能**：

- `normalizeShortcut(shortcut)`: 标准化快捷键格式（如 `Ctrl+Shift+R`）
- `parseShortcut(shortcut)`: 解析快捷键字符串为结构化对象
- `shortcutsEqual(shortcut1, shortcut2)`: 比较两个快捷键是否相等
- `checkShortcutConflict(newShortcut, existingShortcuts)`: 检测快捷键冲突

**快捷键格式**：

- 支持修饰键：`Ctrl`、`Shift`、`Alt`、`Meta`
- 格式：`Ctrl+Shift+KeyR` 或 `KeyV`
- 自动排序和标准化

```16:38:src/plugins/shortcut.ts
export function normalizeShortcut(shortcut: string): string {
  if (!shortcut) return ''

  const parts = shortcut.split('+').map((part) => part.trim())
  const modifiers: ModifierKey[] = []
  let key = ''

  for (const part of parts) {
    const normalizedPart = part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
    if (MODIFIER_KEYS.includes(normalizedPart as ModifierKey)) {
      modifiers.push(normalizedPart as ModifierKey)
    } else {
      key = part.trim()
    }
  }

  if (!key) {
    return ''
  }

  const sortedModifiers = MODIFIER_KEYS.filter((mod) => modifiers.includes(mod))
  return sortedModifiers.length > 0 ? `${sortedModifiers.join('+')}+${key}` : key
}
```

### 2.4 工具管理器

**文件位置**：`src/composables/useCanvasTools.ts`

工具管理器负责创建工具实例、管理生命周期和处理事件。

**核心功能**：

1. **工具实例创建和缓存**：

```31:48:src/composables/useCanvasTools.ts
  function getToolInstance(toolType: string): ToolInstance | null {
    if (!toolInstances.has(toolType)) {
      const plugin = pluginRegistry.getByType(toolType)
      if (plugin) {
        const instance = plugin.createTool({
          tree,
          store,
          isDrawing,
          startPoint,
          currentElement,
          isShiftPressed,
          penPathPoints,
        })
        toolInstances.set(toolType, instance)
      }
    }
    return toolInstances.get(toolType) || null
  }
```

2. **工具切换和生命周期管理**：

```50:67:src/composables/useCanvasTools.ts
  watch(
    () => store.currentTool,
    (newTool, oldTool) => {
      if (oldTool && previousToolInstance?.onDeactivate) {
        previousToolInstance.onDeactivate()
      }

      resetState()
      autoSetMode(newTool)
      autoSetDrag(newTool)

      const newToolInstance = getToolInstance(newTool)
      if (newToolInstance?.onActivate) {
        newToolInstance.onActivate()
      }
      previousToolInstance = newToolInstance
    }
  )
```

3. **事件处理**：

- `DragEvent.START`: 触发 `handleMouseDown`
- `DragEvent.DRAG`: 触发 `updateDrawing`
- `DragEvent.END`: 触发 `finishDrawing`
- `PointerEvent.TAP`: 触发 `handleTap`

4. **快捷键绑定**：

```167:236:src/composables/useCanvasTools.ts
  function buildShortcutMap() {
    const shortcutMap = new Map<string, ToolType>()
    const plugins = pluginRegistry.getAll()

    for (const plugin of plugins) {
      if (plugin.shortcut) {
        const parsed = parseShortcut(plugin.shortcut)
        if (parsed) {
          const shortcutKey = buildShortcutKey(parsed)
          shortcutMap.set(shortcutKey, plugin.type as ToolType)
        }
      }
    }

    return shortcutMap
  }

  function buildShortcutKey(parsed: {
    key: string
    ctrl: boolean
    shift: boolean
    alt: boolean
    meta: boolean
  }): string {
    const modifiers: string[] = []
    if (parsed.ctrl) modifiers.push('Ctrl')
    if (parsed.shift) modifiers.push('Shift')
    if (parsed.alt) modifiers.push('Alt')
    if (parsed.meta) modifiers.push('Meta')
    return modifiers.length > 0 ? `${modifiers.join('+')}+${parsed.key}` : parsed.key
  }

  function matchShortcut(
    e: KeyboardEvent,
    parsed: { key: string; ctrl: boolean; shift: boolean; alt: boolean; meta: boolean }
  ): boolean {
    if (parsed.key !== e.code) return false

    if (parsed.ctrl) {
      if (!(e.ctrlKey || e.metaKey)) return false
    } else if (parsed.meta) {
      if (!e.metaKey) return false
    } else {
      if (e.ctrlKey || e.metaKey) return false
    }

    if (parsed.shift !== e.shiftKey) return false
    if (parsed.alt !== e.altKey) return false

    return true
  }

  const shortcutMap = ref(buildShortcutMap())

  const keyDownId = app.on_(KeyEvent.DOWN, (e: KeyboardEvent) => {
    if (e.code === 'Space') {
      store.enablePanWithSpace()
      return
    }

    for (const [shortcutKey, toolType] of shortcutMap.value.entries()) {
      const parsed = parseShortcut(shortcutKey)
      if (parsed && matchShortcut(e, parsed)) {
        if (toolType !== 'pan' || !store.isPanningWithSpace) {
          store.setTool(toolType)
        }
        break
      }
    }
  })
```

## 3. 插件接口规范

### 3.1 ToolPlugin 接口详解

每个插件必须实现 `ToolPlugin` 接口：

```typescript
interface ToolPlugin {
  id: string // 唯一标识符
  name: string // 插件名称（用于调试和日志）
  type: string // 工具类型（对应 ToolType）
  category?: PluginCategory // 插件分类：'drawing' | 'selection' | 'utility'
  ui?: ToolPluginUI // UI 配置（可选）
  shortcut?: string // 快捷键（可选，格式：'KeyV' 或 'Ctrl+Shift+R'）
  createTool: (context: ToolContext) => ToolInstance // 工厂函数
}
```

**字段说明**：

- `id`: 插件的唯一标识符，用于注册和查询
- `name`: 插件的显示名称，主要用于调试
- `type`: 工具类型，必须与 `ToolType` 类型匹配
- `category`: 插件分类，用于分组管理
- `ui`: UI 配置对象，包含标签、图标等信息
- `shortcut`: 快捷键字符串，支持修饰键组合
- `createTool`: 工厂函数，接收上下文并返回工具实例

### 3.2 ToolContext 上下文对象

`ToolContext` 提供了工具实例运行所需的所有上下文信息：

- `tree`: Leafer 树对象，用于添加/删除元素
- `store`: Canvas store 实例，用于状态管理
- `isDrawing`: 是否正在绘制的响应式引用
- `startPoint`: 绘制起始点的响应式引用
- `currentElement`: 当前正在绘制的元素的响应式引用
- `isShiftPressed`: Shift 键是否按下的响应式引用
- `penPathPoints`: 画笔路径点数组（仅画笔工具使用）

### 3.3 ToolInstance 生命周期方法

工具实例可以实现以下生命周期方法：

- `handleMouseDown?()`: 鼠标按下时调用（在 DragEvent.START 时触发）
- `updateDrawing?(e: DragEvent)`: 拖拽过程中调用（在 DragEvent.DRAG 时触发）
- `finishDrawing?()`: 绘制完成时调用（在 DragEvent.END 时触发）
- `handleTap?(e: PointerEvent)`: 点击时调用（在 PointerEvent.TAP 时触发）
- `onActivate?()`: 工具激活时调用（切换到此工具时）
- `onDeactivate?()`: 工具停用时调用（切换到其他工具时）

### 3.4 插件分类

插件分为三个类别：

- **drawing**: 绘图工具（矩形、圆形、直线、箭头、画笔等）
- **selection**: 选择工具（选择工具）
- **utility**: 实用工具（平移工具）

分类主要用于：

- 插件分组管理
- UI 显示分组
- 功能分类统计

## 4. 内置插件示例

### 4.1 选择工具 - 简单插件示例

选择工具是一个简单的插件示例，不需要复杂的绘制逻辑：

```7:20:src/plugins/builtin/select.ts
export const selectPlugin: ToolPlugin = {
  id: 'select',
  name: 'Select Tool',
  type: 'select',
  category: 'selection',
  ui: {
    label: '选择工具',
    iconComponent: 'i-lucide-mouse-pointer-2',
  },
  shortcut: 'KeyV',
  createTool: () => {
    return {}
  },
}
```

**特点**：

- 不需要实现任何生命周期方法
- 依赖 Leafer Editor 的内置选择功能
- 配置了 UI 和快捷键

### 4.2 矩形工具 - 完整实现示例

矩形工具展示了完整的绘制工具实现：

```8:27:src/plugins/builtin/rect.ts
export const rectPlugin: ToolPlugin = {
  id: 'rect',
  name: 'Rectangle Tool',
  type: 'rect',
  category: 'drawing',
  ui: {
    label: '矩形工具',
    iconComponent: 'i-lucide-square',
  },
  shortcut: 'KeyR',
  createTool: (context) => {
    return useRectTool(
      context.tree,
      context.store,
      context.startPoint,
      context.currentElement,
      context.isShiftPressed
    )
  },
}
```

工具实现（`useRectTool`）：

```11:101:src/plugins/composables/useRectTool.ts
export function useRectTool(
  tree: Tree,
  store: ReturnType<typeof useCanvasStore>,
  startPoint: Ref<Point | null>,
  currentElement: Ref<LeaferElement>,
  isShiftPressed: Ref<boolean>
) {
  function handleMouseDown() {
    if (!tree || !startPoint.value) return

    const rect = new Rect({
      x: startPoint.value.x,
      y: startPoint.value.y,
      width: 0,
      height: 0,
      fill: store.fillColor,
      strokeWidth: 0,
      editable: true,
    })

    currentElement.value = rect
    tree.add(rect)
  }

  function updateDrawing(e: DragEvent) {
    if (!currentElement.value || !startPoint.value) return
    const bounds = e.getPageBounds()

    let width = bounds.width
    let height = bounds.height

    if (isShiftPressed.value) {
      const size = Math.max(Math.abs(width), Math.abs(height))
      width = width < 0 ? -size : size
      height = height < 0 ? -size : size
    }

    currentElement.value.set({
      x: bounds.x,
      y: bounds.y,
      width: Math.abs(width),
      height: Math.abs(height),
    })
  }

  function finishDrawing() {
    if (!currentElement.value || !startPoint.value) return

    const rect = currentElement.value
    if (!(rect instanceof Rect)) return

    const width = rect.width ?? 0
    const height = rect.height ?? 0
    const x = rect.x ?? 0
    const y = rect.y ?? 0

    if (width < 0) {
      rect.x = x + width
      rect.width = Math.abs(width)
    }
    if (height < 0) {
      rect.y = y + height
      rect.height = Math.abs(height)
    }

    const finalWidth = rect.width ?? 0
    const finalHeight = rect.height ?? 0

    if (finalWidth < 5 || finalHeight < 5) {
      tree.remove(rect)
      currentElement.value = null
      return
    }

    const id = `rect-${Date.now()}`
    store.addObject({
      id,
      type: 'rect',
      element: rect,
    })

    store.setTool('select')
    store.selectObject(id)
  }

  return {
    handleMouseDown,
    updateDrawing,
    finishDrawing,
  }
}
```

**实现要点**：

1. **handleMouseDown**: 创建初始矩形元素并添加到画布
2. **updateDrawing**: 根据拖拽更新矩形尺寸，支持 Shift 键绘制正方形
3. **finishDrawing**: 完成绘制，验证尺寸，保存到 store，切换到选择工具

### 4.3 平移工具 - 工具类插件示例

平移工具展示了不需要绘制逻辑的工具插件：

```7:21:src/plugins/builtin/pan.ts
export const panPlugin: ToolPlugin = {
  id: 'pan',
  name: 'Pan Tool',
  type: 'pan',
  category: 'utility',
  ui: {
    label: '平移工具',
    iconComponent: 'i-lucide-hand',
    dividerAfter: true,
  },
  shortcut: 'KeySpace',
  createTool: () => {
    return {}
  },
}
```

**特点**：

- 使用 `dividerAfter: true` 在 UI 中显示分隔符
- 平移逻辑由 `useCanvasTools` 统一处理（通过 `app.config.move.drag`）
- 支持空格键临时激活

## 5. 插件开发指南

### 5.1 创建新插件的步骤

#### 步骤 1: 定义插件对象

在 `src/plugins/builtin/` 目录下创建插件文件：

```typescript
import type { ToolPlugin } from '../types'

export const myToolPlugin: ToolPlugin = {
  id: 'my-tool',
  name: 'My Tool',
  type: 'my-tool',
  category: 'drawing',
  ui: {
    label: '我的工具',
    iconComponent: 'i-lucide-icon-name',
  },
  shortcut: 'KeyM',
  createTool: (context) => {
    // 返回工具实例
  },
}
```

#### 步骤 2: 实现工具逻辑

在 `src/plugins/composables/` 目录下创建工具实现：

```typescript
export function useMyTool(
  tree: Tree,
  store: ReturnType<typeof useCanvasStore>,
  startPoint: Ref<Point | null>,
  currentElement: Ref<LeaferElement>,
  isShiftPressed: Ref<boolean>
) {
  function handleMouseDown() {
    // 创建初始元素
  }

  function updateDrawing(e: DragEvent) {
    // 更新绘制状态
  }

  function finishDrawing() {
    // 完成绘制并保存
  }

  return {
    handleMouseDown,
    updateDrawing,
    finishDrawing,
  }
}
```

#### 步骤 3: 注册插件

在 `src/plugins/builtin/index.ts` 中注册插件：

```typescript
import { myToolPlugin } from './my-tool'

const builtinPlugins = [
  // ... 其他插件
  myToolPlugin,
]

builtinPlugins.forEach((plugin) => {
  pluginRegistry.register(plugin)
})
```

#### 步骤 4: 添加类型定义

在 `src/types/index.ts` 中添加工具类型：

```typescript
export type ToolType =
  | 'select'
  | 'pan'
  // ... 其他类型
  | 'my-tool' // 新增类型
```

### 5.2 实现 ToolInstance 的方法

#### handleMouseDown

在鼠标按下时创建初始元素：

```typescript
function handleMouseDown() {
  if (!tree || !startPoint.value) return

  const element = new SomeElement({
    x: startPoint.value.x,
    y: startPoint.value.y,
    // ... 其他属性
  })

  currentElement.value = element
  tree.add(element)
}
```

#### updateDrawing

在拖拽过程中更新元素：

```typescript
function updateDrawing(e: DragEvent) {
  if (!currentElement.value || !startPoint.value) return
  const bounds = e.getPageBounds()

  // 更新元素属性
  currentElement.value.set({
    // ... 更新属性
  })
}
```

#### finishDrawing

完成绘制并保存：

```typescript
function finishDrawing() {
  if (!currentElement.value) return

  // 验证和清理
  // 保存到 store
  const id = `my-tool-${Date.now()}`
  store.addObject({
    id,
    type: 'my-tool',
    element: currentElement.value,
  })

  // 切换到选择工具
  store.setTool('select')
  store.selectObject(id)
}
```

### 5.3 UI 配置和图标

#### ToolPluginUI 接口

```typescript
interface ToolPluginUI {
  label: string // 工具标签（显示在工具栏）
  iconComponent: string // 图标组件名称（Iconify 格式）
  dividerAfter?: boolean // 是否在此工具后显示分隔符
}
```

#### 图标配置

使用 Iconify 图标格式：`i-lucide-icon-name`

示例：

- `i-lucide-mouse-pointer-2` - 选择工具
- `i-lucide-square` - 矩形工具
- `i-lucide-circle` - 圆形工具
- `i-lucide-hand` - 平移工具

### 5.4 快捷键配置

#### 快捷键格式

- 单个键：`KeyV`、`KeyR`、`KeyC`
- 组合键：`Ctrl+Shift+R`、`Alt+KeyT`

#### 快捷键代码

使用键盘事件的 `code` 属性值：

- 字母键：`KeyA` 到 `KeyZ`
- 数字键：`Digit0` 到 `Digit9`
- 功能键：`F1` 到 `F12`
- 特殊键：`Space`、`Enter`、`Escape`、`ArrowUp` 等

#### 冲突检测

插件注册时会自动检测快捷键冲突，并在控制台输出警告。

### 5.5 最佳实践

1. **使用 Composables 模式**：将工具逻辑封装为 composable 函数，便于复用和测试

2. **合理使用生命周期方法**：

   - `onActivate`: 初始化工具特定状态
   - `onDeactivate`: 清理资源
   - `handleMouseDown`: 创建初始元素
   - `updateDrawing`: 实时更新
   - `finishDrawing`: 验证和保存

3. **状态管理**：

   - 使用 `store` 访问全局状态
   - 使用 `currentElement` 管理当前绘制元素
   - 使用 `isDrawing` 跟踪绘制状态

4. **错误处理**：

   - 检查必要的上下文是否存在
   - 验证元素类型
   - 处理边界情况（如尺寸过小）

5. **用户体验**：
   - 支持 Shift 键绘制规则图形（如正方形、圆形）
   - 绘制完成后自动切换到选择工具
   - 提供清晰的视觉反馈

## 6. 插件注册和使用流程

### 6.1 插件注册流程

1. **导入插件**：在 `src/plugins/builtin/index.ts` 中导入插件定义

2. **添加到列表**：将插件添加到 `builtinPlugins` 数组

3. **批量注册**：遍历数组调用 `pluginRegistry.register()`

```16:30:src/plugins/builtin/index.ts
const builtinPlugins = [
  selectPlugin,
  panPlugin,
  rectPlugin,
  circlePlugin,
  linePlugin,
  arrowPlugin,
  penPlugin,
  textPlugin,
  imagePlugin,
]

builtinPlugins.forEach((plugin) => {
  pluginRegistry.register(plugin)
})
```

4. **自动加载**：在 `useCanvasTools.ts` 或 `ToolSelector.vue` 中导入 `builtin/index.ts`，触发注册

```5:5:src/composables/useCanvasTools.ts
import '@/plugins/builtin'
```

### 6.2 工具切换机制

1. **用户触发**：通过工具栏点击或快捷键触发工具切换

2. **Store 更新**：调用 `store.setTool(toolType)` 更新当前工具

3. **生命周期处理**：

   - 调用旧工具的 `onDeactivate()`
   - 重置绘制状态
   - 设置画布模式（normal/draw）
   - 设置拖拽模式
   - 调用新工具的 `onActivate()`

4. **实例创建**：如果工具实例不存在，通过 `createTool()` 创建并缓存

### 6.3 事件处理流程

#### 拖拽事件流程

1. **DragEvent.START**：

   - 记录起始点
   - 设置 `isDrawing = true`
   - 调用 `handleMouseDown()`

2. **DragEvent.DRAG**：

   - 调用 `updateDrawing(e)`
   - 实时更新元素属性

3. **DragEvent.END**：
   - 调用 `finishDrawing()`
   - 重置绘制状态

#### 点击事件流程

1. **PointerEvent.TAP**：
   - 调用 `handleTap(e)`
   - 用于不需要拖拽的工具（如文本工具）

### 6.4 快捷键绑定

1. **构建快捷键映射**：在 `useCanvasTools` 初始化时，遍历所有插件构建快捷键到工具类型的映射

2. **监听键盘事件**：监听 `KeyEvent.DOWN` 事件

3. **匹配快捷键**：解析按键事件，匹配已注册的快捷键

4. **切换工具**：匹配成功后调用 `store.setTool()` 切换工具

5. **特殊处理**：空格键用于临时激活平移工具

## 7. 扩展性说明

### 7.1 如何添加自定义插件

#### 方式 1: 添加到内置插件

按照第 5 章的步骤，在 `src/plugins/builtin/` 目录下添加新插件。

#### 方式 2: 动态注册插件

在运行时动态注册插件：

```typescript
import { pluginRegistry } from '@/plugins/registry'
import { myCustomPlugin } from './my-custom-plugin'

// 注册插件
pluginRegistry.register(myCustomPlugin)

// 使用插件
const plugin = pluginRegistry.get('my-custom-plugin')
```

### 7.2 插件间交互

插件之间通过以下方式交互：

1. **共享状态**：通过 `store` 共享全局状态
2. **工具切换**：通过 `store.setTool()` 切换工具
3. **事件系统**：通过 Leafer 的事件系统交互

### 7.3 状态管理集成

插件系统与 Pinia store 深度集成：

- **访问状态**：通过 `context.store` 访问所有状态
- **更新状态**：通过 store actions 更新状态
- **响应式**：store 状态变化自动触发响应式更新

**Store 提供的功能**：

- `currentTool`: 当前选中的工具
- `objects`: 画布上的所有对象
- `zoom`: 缩放级别
- `fillColor`, `strokeColor`: 样式属性
- `setTool()`: 切换工具
- `addObject()`: 添加对象
- `removeObject()`: 删除对象
- `selectObject()`: 选择对象

### 7.4 扩展点

插件系统提供了以下扩展点：

1. **自定义工具类型**：添加新的 `ToolType`
2. **自定义插件分类**：扩展 `PluginCategory`
3. **自定义生命周期**：扩展 `ToolInstance` 接口
4. **自定义上下文**：扩展 `ToolContext` 接口
5. **自定义快捷键格式**：扩展快捷键解析逻辑

## 8. 总结

wl-draw 的插件化架构提供了：

- ✅ **清晰的接口规范**：统一的插件接口，易于理解和实现
- ✅ **完整的生命周期**：从注册到使用的完整生命周期管理
- ✅ **强大的扩展性**：轻松添加新工具和功能
- ✅ **类型安全**：完整的 TypeScript 类型支持
- ✅ **良好的开发体验**：清晰的代码组织和文档

通过遵循本文档的规范和最佳实践，开发者可以轻松扩展 wl-draw 的功能，添加自定义绘图工具和实用功能。
